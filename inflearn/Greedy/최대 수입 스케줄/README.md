### 분류

Greedy

### 문제 설명

<p>
현수는 다음 달에 결혼을 합니다.

현수는 결혼식 피로연을 장소를 빌려 3일간 쉬지 않고 하려고 합니다.

피로연에 참석하는 친구들 N명의 참석하는 시간정보를 현수는 친구들에게 미리 요구했습니다.

각 친구들은 자신이 몇 시에 도착해서 몇 시에 떠날 것인지 현수에게 알려주었습니다.

현수는 이 정보를 바탕으로 피로연 장소에 동시에 존재하는 최대 인원수를 구하여 그 인원을 수용할 수 있는 장소를 빌리려고 합니다. 여러분이 현수를 도와주세요.

만약 한 친구가 오는 시간 13, 가는시간 15라면 이 친구는 13시 정각에 피로연 장에 존재하는 것이고 15시 정각에는 존재하지 않는다고 가정합니다.
</p>


### 입력

 <p>
첫 번째 줄에 자연수 N(1<=N<=10,000)이 주어지고, 다음 N개의 줄에 M(1<=M<=10,000)과 D(1<=D<=10,000)가 차례로 주어진다.
  </p>

### 출력

 <p>첫 번째 줄에 최대로 벌 수 있는 수입을 출력한다.</p>

### 풀이 

<p>
우선순위 큐 이용해서 문제를 풀었다.

먼저 Compare 인터페이스 통해 스케줄 객체를 날짜 내림차순으로 정렬.

max에 가장 긴 날짜를 넣어놓자.

예시 입력으로 보면

money day

60 3

30 3

40 2

50 2

30 1

20 1 이런 순으로 정렬이 되고, max =3 이다.

이제 루프를 돌면서 같은 날짜의 수입을 다 큐에 넣고 다음 루프의 날짜가 바뀌면 우선순위 큐를 통해 돈이 가장 높은걸 선택함.

→ 

셋째 날) pQ : { 60, 30 }   —> 60 선택

둘째 날) pq : { 30, 40 ,50 } —> 50 선택

첫째 날) pq : {30, 40, 30, 20 } → 40 선택

여기서 주의할 점

1. 우선순위 큐에 넣을 객체는 CompareTo를 통해 정렬 정해줘야함.

2. `PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.*reverseOrder*());` 해서 Money도 내림차순으로

3. 예를 들어 `PriorityQueue<``Schedule> pQ = new PriorityQueue<>();` 이렇게 해서하면 day랑 money 둘다 우선순위를 정해주지 못함 → compareTo를 통해 money와 day를 둘다 내림차순으로 정렬했다고 치자. {60,3} , {30, 3} ,{50,2} 여기서 내가 원하는 우선순위는
    
    60,3 → 50, 2 → 30,3 이지만 이렇게 안됨. 60,3 → 30,3 → 50,2 로 나와버림 (3 day가 2day보다 크므로) 따라서 `PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.*reverseOrder*());` 이렇게 해주자.
    

1. `if(!pQ.isEmpty()) answer += pQ.poll();` if(!pQ.isEmpty())를 빼주면 안됨 왜냐하면
    
    만약 예시가 {30,3} , {40,2}, {20,1} 이렇게 day가 순차적으로 내려오면 상관없는데
    
    {30,3}, {20,1} 이런식이면 pQ가 비어있는데 answer+=pQ.poll();이 되서 에러가남.
</p>
