### 분류

냅색

### 문제 설명

<p>
다음과 같이 여러 단위의 동전들이 주어져 있을때 거스름돈을 가장 적은 수의 동전으로 교환해주려면 어떻게 주면 되는가?

각 단위의 동전은 무한정 쓸 수 있다.
</p>


### 입력

 <p> 첫 번째 줄에는 동전의 종류개수 N(1<=N<=50)이 주어진다.

두 번째 줄에는 N개의 동전의 종류가 주어지고, 그 다음줄에 거슬러 줄 금액 M(1<=M<=500)이 주어진다.

각 동전의 종류는 100원을 넘지 않는다. </p>

### 출력

 <p>첫 번째 줄에 거슬러 줄 동전의 최소개수를 출력한다.</p>

### 풀이 

<p>dy 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 크기만큼 선언 (m+1)

처음 dy배열의 모든 원소를 임의의 가장 큰 값으로 초기화.

반복문을 시작하기 전 dy[0]=0으로 해줌

coin = {1, 2, 5} 배열이 있다.

이중 for문에서 안쪽 for문의 시작 인덱스는 coin[i]이다. → int j = coint[i]

반복문을 돌면서 dy[j] = Math.min(dy[j], dy[j-coin[i]]+1을 해준다.

dy[j-coin[i]]+1의 의미는 예를 들어서 이해해보자.

밑의 코드를 돌렸을때 결과 값은

        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

---

i=0 : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

i=1 : 0 1 1 2 2 3 3 4 4 5  5   6   6   7   7    8

i=2  : 0 1 1 2 2 1 2 2 3 3 2   3   3   4   4   3 이다.

coin[i]는 그 동전의 종류를 하나 쓰겠다는거다. → coin[0]=1; → 1원을 하나쓰겠다는거

예를 들어서 i=1 → coint[1]=2; → 2원을 하나쓰겠다는건데

i=1일때, 5원을 구한다고 가정해보자. dy[5]= dy[5-coin[1]]+1

→ coin[1]= 2원을 하나쓰면 dy[3] → dy[3](3원)은 2원짜리 한개, 1원짜리 한개로 최소개수가 2개인걸 이미 만들어 저장해놓은 값임. → 여기에 2원짜리 하나 더쓴걸 +1 해줘서

5원 만드는데 2원 2원 1원 이 든다.

그 이후 i=2 에서 5원짜리 한개로 바뀜 ㅎ. 설명이 어렵다 ,,;
